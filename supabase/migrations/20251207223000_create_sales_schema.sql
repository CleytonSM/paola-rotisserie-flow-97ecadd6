-- Drop legacy tables to ensure clean slate
DROP TABLE IF EXISTS public.sale_items CASCADE;
DROP TABLE IF EXISTS public.sale_payments CASCADE;
DROP TABLE IF EXISTS public.sales_items CASCADE; -- Legacy name found in old migrations
DROP TABLE IF EXISTS public.sales CASCADE;

-- Create sales table
CREATE TABLE public.sales (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    display_id BIGINT GENERATED BY DEFAULT AS IDENTITY, -- Auto-incrementing human readable ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    client_id UUID REFERENCES public.clients(id),
    status VARCHAR(20) DEFAULT 'completed' CHECK (status IN ('completed', 'cancelled', 'refunded')),
    notes TEXT,
    change_amount DECIMAL(10,2) DEFAULT 0
);

-- Create sale_payments table
CREATE TABLE public.sale_payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sale_id UUID REFERENCES public.sales(id) ON DELETE CASCADE,
    amount DECIMAL(10,2) NOT NULL,
    payment_method VARCHAR(50) NOT NULL CHECK (payment_method IN ('pix', 'cash', 'card_credit', 'card_debit')),
    pix_key_id UUID REFERENCES public.pix_keys(id),
    machine_id UUID REFERENCES public.card_machines(id),
    card_flag VARCHAR(50),
    installments INTEGER DEFAULT 1,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create sale_items table
CREATE TABLE IF NOT EXISTS public.sale_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sale_id UUID REFERENCES public.sales(id) ON DELETE CASCADE,
    product_catalog_id UUID REFERENCES public.product_catalog(id),
    product_item_id UUID REFERENCES public.product_item(id), -- Nullable for internal items without specific tracking
    name VARCHAR(255) NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    quantity DECIMAL(10,3) NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS
ALTER TABLE public.sales ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sale_payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sale_items ENABLE ROW LEVEL SECURITY;

-- Ensure accounts_receivable has description column
ALTER TABLE public.accounts_receivable ADD COLUMN IF NOT EXISTS description TEXT;

-- Policies for sales
CREATE POLICY "Enable read/write for auth users" ON public.sales
    FOR ALL USING (auth.role() = 'authenticated');

-- Policies for sale_payments
CREATE POLICY "Enable read/write for auth users" ON public.sale_payments
    FOR ALL USING (auth.role() = 'authenticated');

-- Policies for sale_items
CREATE POLICY "Enable read/write for auth users" ON public.sale_items
    FOR ALL USING (auth.role() = 'authenticated');

-- RPC function to complete sale
CREATE OR REPLACE FUNCTION public.complete_sale(
    p_sale_data JSONB,
    p_items_data JSONB,
    p_payments_data JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_sale_id UUID;
    v_display_id BIGINT;
    v_item JSONB;
    v_payment JSONB;
    v_total_paid DECIMAL(10,2) := 0;
BEGIN
    -- 1. Insert Sale
    INSERT INTO public.sales (
        total_amount,
        client_id,
        notes,
        change_amount,
        status
    ) VALUES (
        (p_sale_data->>'total_amount')::DECIMAL,
        (p_sale_data->>'client_id')::UUID,
        p_sale_data->>'notes',
        COALESCE((p_sale_data->>'change_amount')::DECIMAL, 0),
        'completed'
    ) RETURNING id, display_id INTO v_sale_id, v_display_id;

    -- 2. Insert Sale Items
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_items_data)
    LOOP
        INSERT INTO public.sale_items (
            sale_id,
            product_catalog_id,
            product_item_id,
            name,
            unit_price,
            quantity,
            total_price
        ) VALUES (
            v_sale_id,
            (v_item->>'product_catalog_id')::UUID,
            (v_item->>'product_item_id')::UUID,
            v_item->>'name',
            (v_item->>'unit_price')::DECIMAL,
            (v_item->>'quantity')::DECIMAL,
            (v_item->>'total_price')::DECIMAL
        );

        -- If specific item tracked (non-internal usually), mark as sold
        IF (v_item->>'product_item_id') IS NOT NULL THEN
            UPDATE public.product_item
            SET status = 'sold'
            WHERE id = (v_item->>'product_item_id')::UUID;
        END IF;
    END LOOP;

    -- 3. Insert Sale Payments & Calculate Accounts Receivable
    FOR v_payment IN SELECT * FROM jsonb_array_elements(p_payments_data)
    LOOP
        INSERT INTO public.sale_payments (
            sale_id,
            amount,
            payment_method,
            pix_key_id,
            machine_id,
            card_flag,
            installments
        ) VALUES (
            v_sale_id,
            (v_payment->>'amount')::DECIMAL,
            v_payment->>'payment_method',
            (v_payment->>'pix_key_id')::UUID,
            (v_payment->>'machine_id')::UUID,
            v_payment->>'card_flag',
            COALESCE((v_payment->>'installments')::INTEGER, 1)
        );

        v_total_paid := v_total_paid + (v_payment->>'amount')::DECIMAL;
    END LOOP;

    -- 4. Create Accounts Receivable Record
    -- We extract payment info from the first payment method for now, or default to 'mixed'
    
    INSERT INTO public.accounts_receivable (
        description,
        gross_value,
        tax_rate, 
        entry_date,
        status,
        client_id,
        payment_method
    ) VALUES (
        'Venda PDV #' || v_display_id::text,
        (p_sale_data->>'total_amount')::DECIMAL,
        0, -- tax_rate (default 0 for now)
        CURRENT_TIMESTAMP, -- entry_date
        'received',
        (p_sale_data->>'client_id')::UUID,
        (p_payments_data->0->>'payment_method') -- Take first payment method
    );
    
    RETURN jsonb_build_object('sale_id', v_sale_id, 'display_id', v_display_id);
END;
$$;
